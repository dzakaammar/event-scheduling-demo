// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const createEvent = `-- name: CreateEvent :exec
INSERT INTO
    event (
        id,
        title,
        description,
        timezone,
        created_by,
        created_at,
        updated_at
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
`

type CreateEventParams struct {
	ID          string
	Title       string
	Description string
	Timezone    string
	CreatedBy   string
	CreatedAt   time.Time
	UpdatedAt   sql.NullTime
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.ExecContext(ctx, createEvent,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Timezone,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createInvitation = `-- name: CreateInvitation :exec
INSERT INTO
    invitation (id, event_id, user_id, token, status)
VALUES
    ($1, $2, $3, $4, $5)
`

type CreateInvitationParams struct {
	ID      string
	EventID string
	UserID  int32
	Token   string
	Status  int16
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) error {
	_, err := q.db.ExecContext(ctx, createInvitation,
		arg.ID,
		arg.EventID,
		arg.UserID,
		arg.Token,
		arg.Status,
	)
	return err
}

const createSchedule = `-- name: CreateSchedule :exec
INSERT INTO
    schedule (
        id,
        event_id,
        start_time,
        "duration",
        is_full_day,
        recurring_interval,
        recurring_type
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
`

type CreateScheduleParams struct {
	ID                string
	EventID           string
	StartTime         int64
	Duration          int64
	IsFullDay         bool
	RecurringInterval int64
	RecurringType     string
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) error {
	_, err := q.db.ExecContext(ctx, createSchedule,
		arg.ID,
		arg.EventID,
		arg.StartTime,
		arg.Duration,
		arg.IsFullDay,
		arg.RecurringInterval,
		arg.RecurringType,
	)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM
    event
WHERE
    id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const findEventByID = `-- name: FindEventByID :one
SELECT
    id, title, description, timezone, created_by, created_at, updated_at
FROM
    event
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) FindEventByID(ctx context.Context, id string) (Event, error) {
	row := q.db.QueryRowContext(ctx, findEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Timezone,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findInvitationsByEventID = `-- name: FindInvitationsByEventID :many
SELECT
    id, event_id, user_id, token, status, updated_at
FROM
    invitation
WHERE
    event_id = $1
`

func (q *Queries) FindInvitationsByEventID(ctx context.Context, eventID string) ([]Invitation, error) {
	rows, err := q.db.QueryContext(ctx, findInvitationsByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.Token,
			&i.Status,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSchedulesByEventID = `-- name: FindSchedulesByEventID :many
SELECT
    id, event_id, start_time, duration, is_full_day, recurring_interval, recurring_type
FROM
    schedule
WHERE
    event_id = $1
`

func (q *Queries) FindSchedulesByEventID(ctx context.Context, eventID string) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, findSchedulesByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StartTime,
			&i.Duration,
			&i.IsFullDay,
			&i.RecurringInterval,
			&i.RecurringType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE
    event
SET
    title = $1,
    description = $2,
    timezone = $3,
    updated_at = $4
`

type UpdateEventParams struct {
	Title       string
	Description string
	Timezone    string
	UpdatedAt   sql.NullTime
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.ExecContext(ctx, updateEvent,
		arg.Title,
		arg.Description,
		arg.Timezone,
		arg.UpdatedAt,
	)
	return err
}

const upsertInvitation = `-- name: UpsertInvitation :exec
INSERT INTO
    invitation (id, event_id, user_id, token, status)
VALUES
    ($1, $2, $3, $4, $5) ON CONFLICT (id, event_id) DO
UPDATE
SET
    user_id = $3,
    token = $4,
    status = $5
`

type UpsertInvitationParams struct {
	ID      string
	EventID string
	UserID  int32
	Token   string
	Status  int16
}

func (q *Queries) UpsertInvitation(ctx context.Context, arg UpsertInvitationParams) error {
	_, err := q.db.ExecContext(ctx, upsertInvitation,
		arg.ID,
		arg.EventID,
		arg.UserID,
		arg.Token,
		arg.Status,
	)
	return err
}

const upsertSchedule = `-- name: UpsertSchedule :exec
INSERT INTO
    schedule (
        id,
        event_id,
        start_time,
        "duration",
        is_full_day,
        recurring_interval,
        recurring_type
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT (id, event_id) DO
UPDATE
SET
    start_time = $3,
    "duration" = $4,
    recurring_interval = $5,
    recurring_type = $6
`

type UpsertScheduleParams struct {
	ID                string
	EventID           string
	StartTime         int64
	Duration          int64
	IsFullDay         bool
	RecurringInterval int64
	RecurringType     string
}

func (q *Queries) UpsertSchedule(ctx context.Context, arg UpsertScheduleParams) error {
	_, err := q.db.ExecContext(ctx, upsertSchedule,
		arg.ID,
		arg.EventID,
		arg.StartTime,
		arg.Duration,
		arg.IsFullDay,
		arg.RecurringInterval,
		arg.RecurringType,
	)
	return err
}
